#!/bin/env python3
from sys import argv
from time import asctime
from xml.dom import minidom

PSI_2_KPA = 6.89475729
RPM_COUNT = 16
LOAD_COUNT = 16




def getOneElementByTagName(dom_element,tagname):
    items=dom_element.getElementsByTagName(tagname)
    if len(items) > 1:
            raise Exception("more than one item with tag name: '"+tagname+"' found")
    return items[0]

def strip_strings_in_list_of_strings_recursive(liste):
    l=[]
    for i in liste:
        if type(i) is type(''):
            l.append(i.strip())
        elif type(i) is type([]):
            l.append(strip_strings_in_list_of_strings_recursive(i))
    return l
        
def remove_empty_string_out_of_list_recursive(liste):
    l=[]
    for i in liste:
        if type(i) is type(""):
            if not i=='':
                l.append(i)
        elif type(i) is type([]):
            l.append( remove_empty_string_out_of_list_recursive(i) )
    return l

def remove_empty_list_out_of_list_recursive(liste):
    l=[]
    for i in liste:
        if type(i) is type([]):
            if not len(i)==0:
                l.append(i)
        else:
            l.append(i)
    return l

def split_em_all_on_space(things):
    l=[]
    for onething in things:
        try:
            l.append(onething.split(" "))
        except e:
            print("maybe you try to split some unsplitable stuff, or whatever")
            raise e
    return l
        
            


def parse_TSxml_for_table(path):
    xmldoc = minidom.parse(path)
    table = getOneElementByTagName(xmldoc,"table")
    x = getOneElementByTagName(table,"xAxis")
    y = getOneElementByTagName(table,"yAxis")
    z     = getOneElementByTagName(table,"zValues")
    x_data = x.childNodes[0].data
    y_data = y.childNodes[0].data
    z_data = z.childNodes[0].data
    x = x_data.splitlines()
    y = y_data.splitlines()
    z = split_em_all_on_space(z_data.splitlines())
    x = strip_strings_in_list_of_strings_recursive(x)
    y = strip_strings_in_list_of_strings_recursive(y)
    z = strip_strings_in_list_of_strings_recursive(z)
    x = remove_empty_string_out_of_list_recursive(x)
    y = remove_empty_string_out_of_list_recursive(y)
    z = remove_empty_string_out_of_list_recursive(z)
    x = remove_empty_list_out_of_list_recursive(x)
    y = remove_empty_list_out_of_list_recursive(y)
    z = remove_empty_list_out_of_list_recursive(z)
    return x,y,z

def space(num):
    s=""
    for i in range(0,num):
        s=s+" "
    return s




def gen_header( x , tool_name = argv[0] , columnwidth=7, columnspace=4):
    l=[]
    s=""
    s=s+"/* Generated by " + tool_name + " on " + asctime() + "*/\n"
    l.append(s)

    s=""
    s=s+'/* rpm -> '
    for rpmIndex in range( 0, RPM_COUNT ):
        valuestring ="{:4.0f}".format(float(x[rpmIndex]))
        valuestring=around_pad_space(valuestring,columnwidth)
        s=s+space(columnspace)+valuestring
    l.append( s + space(4) +'*/'+'\n' )

    l.append("/*load*/" + '\n')
    l.append("/*  | */" + '\n')
    l.append("/*  v */" + '\n')
    l.append("/*    */" + '\n')

    return l
    
def pre_pad_space( string, pad_to_len ):
    expected_len = pad_to_len
    d = expected_len - len(string)
    if d == 0:
        pass
    elif d > 0:
        for i in range(0,d):
            string = " " + string
    elif d < 0:
        raise Exception("Error string is too long somehow. String: " +string)
    else:
        raise Exception("Unexpected state")
    return string


def around_pad_space( string, pad_to_len ):
    expected_len = pad_to_len
    d = expected_len - len(string)
    if d == 0:
        pass
    elif d > 0:
        suffix=int(d/2)
        prefix=d-suffix
        for i in range(0,prefix):
            string = " " + string
        for j in range(0,suffix):
            string = string + " "
    elif d < 0:
        raise Exception("Error string is too long somehow. String: " +string)
    else:
        raise Exception("Unexpected state")
    return string

def genLine(x, y, z , loadIndex ,columnwidth=7,columnspace=4):
    # first need loadindex  as comment for the line
    s ="/* "+ "{:2.1f}".format(float(y[loadIndex])) + " */"
    # need bracket stuff
    s = s + "{"
    for rpmIndex  in range( 0, len(x)):
            value = float(z[loadIndex][rpmIndex] )
            valuestring = "{:2.2f}".format( value )
            if value > 0:
                valuestring = '+' + valuestring
            valuestring = valuestring + ','
            valuestring = pre_pad_space(valuestring,7)
            s = s + space(4) + valuestring
    s = s + "    },\n";
    return s

def gen_lines(x,y,z):
    lines=[]
    for loadIndex in range(0,len(y)):
        l=genLine(x,y,z,loadIndex)
        lines.append(l)
    return lines


"""
gimme filename for first arg then get c code
"""
if not (len(argv) == 2):
    raise Exception("error expected one arg: path to file")
print("parsing: "+argv[1]+ " for a ignition table")
x,y,z=parse_TSxml_for_table(argv[1])
header=gen_header(x)
lines=gen_lines(x,y,z)

all_stuff_in_one_string = ""
for i in header:
    all_stuff_in_one_string=all_stuff_in_one_string+i
for i in lines:
    all_stuff_in_one_string=all_stuff_in_one_string+i

print(all_stuff_in_one_string)
